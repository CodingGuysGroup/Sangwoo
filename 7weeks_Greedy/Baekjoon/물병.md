### `문제 설명`

지민이는 N개의 물병을 가지고 있다. 각 물병에는 물을 무한대로 부을 수 있다. 처음에 모든 물병에는 물이 1리터씩 들어있다. 지민이는 이 물병을 또 다른 장소로 옮기려고 한다. 지민이는 한 번에 K개의 물병을 옮길 수 있다. 하지만, 지민이는 물을 낭비하기는 싫고, 이동을 한 번보다 많이 하기는 싫다. 따라서, 지민이는 물병의 물을 적절히 재분배해서, K개를 넘지 않는 비어있지 않은 물병을 만들려고 한다.

물은 다음과 같이 재분배 한다.

먼저 같은 양의 물이 들어있는 물병 두 개를 고른다. 그 다음에 한 개의 물병에 다른 한 쪽에 있는 물을 모두 붓는다. 이 방법을 필요한 만큼 계속 한다.

이런 제약 때문에, N개로 K개를 넘지않는 비어있지 않은 물병을 만드는 것이 불가능할 수도 있다. 다행히도, 새로운 물병을 살 수 있다. 상점에서 사는 물병은 물이 1리터 들어있다.

예를 들어, N=3이고, K=1일 때를 보면, 물병 3개로 1개를 만드는 것이 불가능하다. 한 병을 또다른 병에 부으면, 2리터가 들어있는 물병 하나와, 1리터가 들어있는 물병 하나가 남는다. 만약 상점에서 한 개의 물병을 산다면, 2리터가 들어있는 물병 두 개를 만들 수 있고, 마지막으로 4리터가 들어있는 물병 한 개를 만들 수 있다

### `제한 사항`

첫째 줄에 N과 K가 주어진다. N은 107보다 작거나 같은 자연수이고, K는 1,000보다 작거나 같은 자연수이다.

### `결과`

첫째 줄에 상점에서 사야하는 물병의 최솟값을 출력한다. 만약 정답이 없을 경우에는 -1을 출력한다.

### `입출력 예`
### Case 1

|input|output|
|---|---|
|3 1|1|

### Case 2

|input|output|
|---|---|
|13 2|3|

### Case 3

|input|output|
|---|---|
|1000000 5|15808|

### `ANS`

----

```
import sys
input=sys.stdin.readline
n,k=map(int,input().split())
stack=[]
n=bin(n)[2:] #13->ob1101 에서 1101 만 가져옴
total_last_number=0
for i in range(len(n)):
    if n[i]=='1': #13 2 인 경우 1101에서 stack에 8,4,1 저장
        stack.append(2**(len(n)-1-i))
if len(stack)<=k: #이때 13 3 이나 13 5 처럼 구성 원소가 8,4,1 3개인데 k=3 이면 물병 안사도 되고 k=5되면 구성할 수 없으므로 0 출력
    print(0)
    exit()
#8,4,1에서 물병 1개 사면 8,4,1,1->8,4,2 물병 1개 더 사면 8,4,2,1 하나 더 사면 8,4,2,1,1->8,4,2,2->8,4,4->8,8 이므로 3개 사야함
#따라서 k개의 물병으로 물을 맞추기 위해선 stack의 구성원소 개수에서 k개를 뺀 개수를 pop() 하여 더해놓고 stack의 마지막 값과 더해놓은 값을 뺴면 됨
#(13,2 경우 stack의 구성원소 [8,4,1] k=2이므로 stack의 구성원소 개수 3에서 k=2를 빼면 1이므로 pop()을 한번한 값을 total_last_number로 받고
#이때 total_last_number=1 그 후 stack의 마지막 값 4와 total_last_number=1 을 뺴면 3이 나옴 -> 물병을 3개 사야 8,4,1 중 1과 합체된 후 4까지 합체되어 k=2를 구성할 수 있게 됨
#1000000 5 경우 stack 구성원소 = [524288, 262144, 131072, 65536, 16384, 512, 64] => 7개 7-5=2 이므로 2개 pop()하고 pop()한 값끼리 더함 -> 576
#pop() 한 후 stack = [524288, 262144, 131072, 65536, 16384] stack의 마지막 값 16384-576(pop한거 다 더한값)=15808
for _ in range(len(stack)-k): 
    total_last_number+=stack.pop()
print(stack[-1]-total_last_number)

```

### `Runtime and Memory`
![image](https://github.com/CodingGuysGroup/Sangwoo/assets/106041072/c253ec88-4e88-43b6-8ad5-756335585d31)
